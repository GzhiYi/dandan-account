{"version":3,"sources":["index.js","base.js","tick-method/register.js","category/base.js","category/time.js","util/time.js","util/bisector.js","continuous/linear.js","continuous/base.js","continuous/log.js","util/math.js","continuous/pow.js","continuous/time.js","continuous/quantize.js","continuous/quantile.js","factory.js","identity/index.js","tick-method/index.js","tick-method/cat.js","util/extended.js","util/pretty-number.js","tick-method/d3-linear.js","util/d3-linear.js","util/interval.js","util/strict-limit.js","tick-method/linear.js","tick-method/log.js","tick-method/pow.js","util/pretty.js","tick-method/quantile.js","tick-method/r-prettry.js","tick-method/time.js","tick-method/time-cat.js","tick-method/time-pretty.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,ACHA,AJYA,AENA;ADIA,AENA,ACHA,AJYA,AENA;ADIA,AENA,ACHA,AJYA,AENA;ADIA,AENA,ACHA,AJYA,AENA,AGTA;AJaA,AENA,ACHA,AJYA,AENA,AGTA;AJaA,AENA,ACHA,AJYA,AENA,AGTA;AJaA,AENA,ACHA,AJYA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AJYA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AJYA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AGTA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AGTA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AGTA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,APqBA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AENA,AIZA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AMlBA,ADGA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AT2BA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AXiCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AXiCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AXiCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,ACHA,AZoCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,ACHA,AZoCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,ACHA,AZoCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AENA,ADGA,AZoCA,AMlBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AENA,ADGA,ANkBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AENA,ADGA,ANkBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,ANkBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,ANkBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,ANkBA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,AGTA,AT2BA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,AGTA,AT2BA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,AGTA,AT2BA,AIZA,ALeA;AJaA,AENA,ACHA,AIZA,ADGA,AENA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,APqBA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AGTA,ACHA,AENA,ADGA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AENA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AT2BA,AU9BA,Af6CA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,ALeA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AKfA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AQxBA,AHSA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AQxBA,AHSA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AJYA,AQxBA,AHSA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,ACHA,AIZA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AIZA,ACHA,AJYA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AIZA,ACHA,AJYA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AENA,AENA,ADGA,AIZA,AENA,AGTA,AIZA,ACHA,AJYA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AGTA,AIZA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AOrBA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AOrBA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,Ac1CA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AOrBA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AOrBA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AIZA,AENA,AOrBA,ACHA,ACHA,ALeA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,APqBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,APqBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,APqBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ARwBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ARwBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ARwBA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ACHA,AT2BA,AHSA,AIZA,AbuCA,AkBtDA,AJYA,AnByDA;AJaA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ACHA,AT2BA,AHSA,AIZA,AbuCA,AkBtDA,AJYA;AvBsEA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,ACHA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AENA,AKfA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AOrBA,ACHA,AIZA,ADGA,AavCA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA,AJYA;AvBsEA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AIZA,AKfA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AOrBA,ACHA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,Ac1CA,AGTA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,ACHA,AENA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,AGTA,ACHA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AIZA,ADGA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AQxBA,AGTA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AFMA,AT2BA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;A3BkFA,AWjCA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;AhBiDA,AiBnDA,AIZA,AXiCA,AHSA,AS3BA;ACFA,AIZA,AXiCA,AHSA,AS3BA;ACFA,AIZA,AXiCA,AHSA,AS3BA;ACFA,AIZA,AXiCA,AHSA,AS3BA;ACFA,AIZA,AXiCA,AHSA,AS3BA;AKdA,AXiCA,AHSA,AS3BA;AKdA,AXiCA,AHSA,AS3BA;AKdA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,AXiCA,AHSA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AczCA,Ad0CA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerTickMethod = exports.getTickMethod = exports.registerScale = exports.getScale = exports.Scale = exports.Quantize = exports.Quantile = exports.TimeCat = exports.Time = exports.Pow = exports.Log = exports.Linear = exports.Identity = exports.Category = void 0;\nvar base_1 = require(\"./base\");\nexports.Scale = base_1.default;\nvar base_2 = require(\"./category/base\");\nexports.Category = base_2.default;\nvar time_1 = require(\"./category/time\");\nexports.TimeCat = time_1.default;\nvar linear_1 = require(\"./continuous/linear\");\nexports.Linear = linear_1.default;\nvar log_1 = require(\"./continuous/log\");\nexports.Log = log_1.default;\nvar pow_1 = require(\"./continuous/pow\");\nexports.Pow = pow_1.default;\nvar time_2 = require(\"./continuous/time\");\nexports.Time = time_2.default;\nvar quantize_1 = require(\"./continuous/quantize\");\nexports.Quantize = quantize_1.default;\nvar quantile_1 = require(\"./continuous/quantile\");\nexports.Quantile = quantile_1.default;\nvar factory_1 = require(\"./factory\");\nObject.defineProperty(exports, \"getScale\", { enumerable: true, get: function () { return factory_1.getScale; } });\nObject.defineProperty(exports, \"registerScale\", { enumerable: true, get: function () { return factory_1.registerScale; } });\nvar index_1 = require(\"./identity/index\");\nexports.Identity = index_1.default;\nvar index_2 = require(\"./tick-method/index\");\nObject.defineProperty(exports, \"getTickMethod\", { enumerable: true, get: function () { return index_2.getTickMethod; } });\nObject.defineProperty(exports, \"registerTickMethod\", { enumerable: true, get: function () { return index_2.registerTickMethod; } });\n(0, factory_1.registerScale)('cat', base_2.default);\n(0, factory_1.registerScale)('category', base_2.default);\n(0, factory_1.registerScale)('identity', index_1.default);\n(0, factory_1.registerScale)('linear', linear_1.default);\n(0, factory_1.registerScale)('log', log_1.default);\n(0, factory_1.registerScale)('pow', pow_1.default);\n(0, factory_1.registerScale)('time', time_2.default);\n(0, factory_1.registerScale)('timeCat', time_1.default);\n(0, factory_1.registerScale)('quantize', quantize_1.default);\n(0, factory_1.registerScale)('quantile', quantile_1.default);\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar register_1 = require(\"./tick-method/register\");\nvar Scale = /** @class */ (function () {\n    function Scale(cfg) {\n        /**\n         * 度量的类型\n         */\n        this.type = 'base';\n        /**\n         * 是否分类类型的度量\n         */\n        this.isCategory = false;\n        /**\n         * 是否线性度量，有linear, time 度量\n         */\n        this.isLinear = false;\n        /**\n         * 是否连续类型的度量，linear,time,log, pow, quantile, quantize 都支持\n         */\n        this.isContinuous = false;\n        /**\n         * 是否是常量的度量，传入和传出一致\n         */\n        this.isIdentity = false;\n        this.values = [];\n        this.range = [0, 1];\n        this.ticks = [];\n        this.__cfg__ = cfg;\n        this.initCfg();\n        this.init();\n    }\n    // 对于原始值的必要转换，如分类、时间字段需转换成数值，用transform/map命名可能更好\n    Scale.prototype.translate = function (v) {\n        return v;\n    };\n    /** 重新初始化 */\n    Scale.prototype.change = function (cfg) {\n        // 覆盖配置项，而不替代\n        (0, util_1.assign)(this.__cfg__, cfg);\n        this.init();\n    };\n    Scale.prototype.clone = function () {\n        return this.constructor(this.__cfg__);\n    };\n    /** 获取坐标轴需要的ticks */\n    Scale.prototype.getTicks = function () {\n        var _this = this;\n        return (0, util_1.map)(this.ticks, function (tick, idx) {\n            if ((0, util_1.isObject)(tick)) {\n                // 仅当符合Tick类型时才有意义\n                return tick;\n            }\n            return {\n                text: _this.getText(tick, idx),\n                tickValue: tick,\n                value: _this.scale(tick), // scaled\n            };\n        });\n    };\n    /** 获取Tick的格式化结果 */\n    Scale.prototype.getText = function (value, key) {\n        var formatter = this.formatter;\n        var res = formatter ? formatter(value, key) : value;\n        if ((0, util_1.isNil)(res) || !(0, util_1.isFunction)(res.toString)) {\n            return '';\n        }\n        return res.toString();\n    };\n    // 获取配置项中的值，当前 scale 上的值可能会被修改\n    Scale.prototype.getConfig = function (key) {\n        return this.__cfg__[key];\n    };\n    // scale初始化\n    Scale.prototype.init = function () {\n        (0, util_1.assign)(this, this.__cfg__);\n        this.setDomain();\n        if ((0, util_1.isEmpty)(this.getConfig('ticks'))) {\n            this.ticks = this.calculateTicks();\n        }\n    };\n    // 子类上覆盖某些属性，不能直接在类上声明，否则会被覆盖\n    Scale.prototype.initCfg = function () { };\n    Scale.prototype.setDomain = function () { };\n    Scale.prototype.calculateTicks = function () {\n        var tickMethod = this.tickMethod;\n        var ticks = [];\n        if ((0, util_1.isString)(tickMethod)) {\n            var method = (0, register_1.getTickMethod)(tickMethod);\n            if (!method) {\n                throw new Error('There is no method to to calculate ticks!');\n            }\n            ticks = method(this);\n        }\n        else if ((0, util_1.isFunction)(tickMethod)) {\n            ticks = tickMethod(this);\n        }\n        return ticks;\n    };\n    // range 的最小值\n    Scale.prototype.rangeMin = function () {\n        return this.range[0];\n    };\n    // range 的最大值\n    Scale.prototype.rangeMax = function () {\n        return this.range[1];\n    };\n    /** 定义域转 0~1 */\n    Scale.prototype.calcPercent = function (value, min, max) {\n        if ((0, util_1.isNumber)(value)) {\n            return (value - min) / (max - min);\n        }\n        return NaN;\n    };\n    /** 0~1转定义域 */\n    Scale.prototype.calcValue = function (percent, min, max) {\n        return min + percent * (max - min);\n    };\n    return Scale;\n}());\nexports.default = Scale;\n//# sourceMappingURL=base.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerTickMethod = exports.getTickMethod = void 0;\nvar methodCache = {};\n/**\n * 获取计算 ticks 的方法\n * @param key 键值\n * @returns 计算 ticks 的方法\n */\nfunction getTickMethod(key) {\n    return methodCache[key];\n}\nexports.getTickMethod = getTickMethod;\n/**\n * 注册计算 ticks 的方法\n * @param key 键值\n * @param method 方法\n */\nfunction registerTickMethod(key, method) {\n    methodCache[key] = method;\n}\nexports.registerTickMethod = registerTickMethod;\n//# sourceMappingURL=register.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"../base\");\n/**\n * 分类度量\n * @class\n */\nvar Category = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Category, _super);\n    function Category() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'cat';\n        _this.isCategory = true;\n        return _this;\n    }\n    Category.prototype.buildIndexMap = function () {\n        if (!this.translateIndexMap) {\n            this.translateIndexMap = new Map();\n            // 重新构建缓存\n            for (var i = 0; i < this.values.length; i++) {\n                this.translateIndexMap.set(this.values[i], i);\n            }\n        }\n    };\n    Category.prototype.translate = function (value) {\n        // 按需构建 map\n        this.buildIndexMap();\n        // 找得到\n        var idx = this.translateIndexMap.get(value);\n        if (idx === undefined) {\n            idx = (0, util_1.isNumber)(value) ? value : NaN;\n        }\n        return idx;\n    };\n    Category.prototype.scale = function (value) {\n        var order = this.translate(value);\n        // 分类数据允许 0.5 范围内调整\n        // if (order < this.min - 0.5 || order > this.max + 0.5) {\n        //   return NaN;\n        // }\n        var percent = this.calcPercent(order, this.min, this.max);\n        return this.calcValue(percent, this.rangeMin(), this.rangeMax());\n    };\n    Category.prototype.invert = function (scaledValue) {\n        var domainRange = this.max - this.min;\n        var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());\n        var idx = Math.round(domainRange * percent) + this.min;\n        if (idx < this.min || idx > this.max) {\n            return NaN;\n        }\n        return this.values[idx];\n    };\n    Category.prototype.getText = function (value) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var v = value;\n        // value为index\n        if ((0, util_1.isNumber)(value) && !this.values.includes(value)) {\n            v = this.values[v];\n        }\n        return _super.prototype.getText.apply(this, (0, tslib_1.__spreadArray)([v], args, false));\n    };\n    // 复写属性\n    Category.prototype.initCfg = function () {\n        this.tickMethod = 'cat';\n    };\n    // 设置 min, max\n    Category.prototype.setDomain = function () {\n        // 用户有可能设置 min\n        if ((0, util_1.isNil)(this.getConfig('min'))) {\n            this.min = 0;\n        }\n        if ((0, util_1.isNil)(this.getConfig('max'))) {\n            var size = this.values.length;\n            this.max = size > 1 ? size - 1 : size;\n        }\n        // scale.init 的时候清除缓存\n        if (this.translateIndexMap) {\n            this.translateIndexMap = undefined;\n        }\n    };\n    return Category;\n}(base_1.default));\nexports.default = Category;\n//# sourceMappingURL=base.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar time_1 = require(\"../util/time\");\nvar base_1 = require(\"./base\");\n/**\n * 时间分类度量\n * @class\n */\nvar TimeCat = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(TimeCat, _super);\n    function TimeCat() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'timeCat';\n        return _this;\n    }\n    /**\n     * @override\n     */\n    TimeCat.prototype.translate = function (value) {\n        value = (0, time_1.toTimeStamp)(value);\n        var index = this.values.indexOf(value);\n        if (index === -1) {\n            if ((0, util_1.isNumber)(value) && value < this.values.length) {\n                index = value;\n            }\n            else {\n                index = NaN;\n            }\n        }\n        return index;\n    };\n    /**\n     * 由于时间类型数据需要转换一下，所以复写 getText\n     * @override\n     */\n    TimeCat.prototype.getText = function (value, tickIndex) {\n        var index = this.translate(value);\n        if (index > -1) {\n            var result = this.values[index];\n            var formatter = this.formatter;\n            result = formatter ? formatter(result, tickIndex) : (0, time_1.timeFormat)(result, this.mask);\n            return result;\n        }\n        return value;\n    };\n    TimeCat.prototype.initCfg = function () {\n        this.tickMethod = 'time-cat';\n        this.mask = 'YYYY-MM-DD';\n        this.tickCount = 7; // 一般时间数据会显示 7， 14， 30 天的数字\n    };\n    TimeCat.prototype.setDomain = function () {\n        var values = this.values;\n        // 针对时间分类类型，会将时间统一转换为时间戳\n        (0, util_1.each)(values, function (v, i) {\n            values[i] = (0, time_1.toTimeStamp)(v);\n        });\n        values.sort(function (v1, v2) {\n            return v1 - v2;\n        });\n        _super.prototype.setDomain.call(this);\n    };\n    return TimeCat;\n}(base_1.default));\nexports.default = TimeCat;\n//# sourceMappingURL=time.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTickInterval = exports.YEAR = exports.MONTH = exports.DAY = exports.HOUR = exports.MINUTE = exports.SECOND = exports.toTimeStamp = exports.timeFormat = void 0;\nvar util_1 = require(\"@antv/util\");\nvar fecha_1 = require(\"fecha\");\nvar fecha1 = require(\"fecha\");\nvar bisector_1 = require(\"./bisector\");\nvar FORMAT_METHOD = 'format';\nfunction timeFormat(time, mask) {\n    var method = fecha1[FORMAT_METHOD] || fecha_1.default[FORMAT_METHOD];\n    return method(time, mask);\n}\nexports.timeFormat = timeFormat;\n/**\n * 转换成时间戳\n * @param value 时间值\n */\nfunction toTimeStamp(value) {\n    if ((0, util_1.isString)(value)) {\n        if (value.indexOf('T') > 0) {\n            value = new Date(value).getTime();\n        }\n        else {\n            // new Date('2010/01/10') 和 new Date('2010-01-10') 的差别在于:\n            // 如果仅有年月日时，前者是带有时区的: Fri Jan 10 2020 02:40:13 GMT+0800 (中国标准时间)\n            // 后者会格式化成 Sun Jan 10 2010 08:00:00 GMT+0800 (中国标准时间)\n            value = new Date(value.replace(/-/gi, '/')).getTime();\n        }\n    }\n    if ((0, util_1.isDate)(value)) {\n        value = value.getTime();\n    }\n    return value;\n}\nexports.toTimeStamp = toTimeStamp;\nvar SECOND = 1000;\nexports.SECOND = SECOND;\nvar MINUTE = 60 * SECOND;\nexports.MINUTE = MINUTE;\nvar HOUR = 60 * MINUTE;\nexports.HOUR = HOUR;\nvar DAY = 24 * HOUR;\nexports.DAY = DAY;\nvar MONTH = DAY * 31;\nexports.MONTH = MONTH;\nvar YEAR = DAY * 365;\nexports.YEAR = YEAR;\nvar intervals = [\n    ['HH:mm:ss', SECOND],\n    ['HH:mm:ss', SECOND * 10],\n    ['HH:mm:ss', SECOND * 30],\n    ['HH:mm', MINUTE],\n    ['HH:mm', MINUTE * 10],\n    ['HH:mm', MINUTE * 30],\n    ['HH', HOUR],\n    ['HH', HOUR * 6],\n    ['HH', HOUR * 12],\n    ['YYYY-MM-DD', DAY],\n    ['YYYY-MM-DD', DAY * 4],\n    ['YYYY-WW', DAY * 7],\n    ['YYYY-MM', MONTH],\n    ['YYYY-MM', MONTH * 4],\n    ['YYYY-MM', MONTH * 6],\n    ['YYYY', DAY * 380], // 借鉴echarts，保证每个周期累加时不会碰到恰巧不够的问题\n];\nfunction getTickInterval(min, max, tickCount) {\n    var target = (max - min) / tickCount;\n    var idx = (0, bisector_1.default)(function (o) { return o[1]; })(intervals, target) - 1;\n    var interval = intervals[idx];\n    if (idx < 0) {\n        interval = intervals[0];\n    }\n    else if (idx >= intervals.length) {\n        interval = (0, util_1.last)(intervals);\n    }\n    return interval;\n}\nexports.getTickInterval = getTickInterval;\n//# sourceMappingURL=time.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\n/**\n * 二分右侧查找\n * https://github.com/d3/d3-array/blob/master/src/bisector.js\n */\nfunction default_1(getter) {\n    /**\n     * x: 目标值\n     * lo: 起始位置\n     * hi: 结束位置\n     */\n    return function (a, x, _lo, _hi) {\n        var lo = (0, util_1.isNil)(_lo) ? 0 : _lo;\n        var hi = (0, util_1.isNil)(_hi) ? a.length : _hi;\n        while (lo < hi) {\n            var mid = (lo + hi) >>> 1;\n            if (getter(a[mid]) > x) {\n                hi = mid;\n            }\n            else {\n                lo = mid + 1;\n            }\n        }\n        return lo;\n    };\n}\nexports.default = default_1;\n//# sourceMappingURL=bisector.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\n/**\n * 线性度量\n * @class\n */\nvar Linear = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Linear, _super);\n    function Linear() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'linear';\n        _this.isLinear = true;\n        return _this;\n    }\n    Linear.prototype.invert = function (value) {\n        var percent = this.getInvertPercent(value);\n        return this.min + percent * (this.max - this.min);\n    };\n    Linear.prototype.initCfg = function () {\n        this.tickMethod = 'wilkinson-extended';\n        this.nice = false;\n    };\n    return Linear;\n}(base_1.default));\nexports.default = Linear;\n//# sourceMappingURL=linear.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"../base\");\n/**\n * 连续度量的基类\n * @class\n */\nvar Continuous = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Continuous, _super);\n    function Continuous() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isContinuous = true;\n        return _this;\n    }\n    Continuous.prototype.scale = function (value) {\n        if ((0, util_1.isNil)(value)) {\n            return NaN;\n        }\n        var rangeMin = this.rangeMin();\n        var rangeMax = this.rangeMax();\n        var max = this.max;\n        var min = this.min;\n        if (max === min) {\n            return rangeMin;\n        }\n        var percent = this.getScalePercent(value);\n        return rangeMin + percent * (rangeMax - rangeMin);\n    };\n    Continuous.prototype.init = function () {\n        _super.prototype.init.call(this);\n        // init 完成后保证 min, max 包含 ticks 的范围\n        var ticks = this.ticks;\n        var firstTick = (0, util_1.head)(ticks);\n        var lastTick = (0, util_1.last)(ticks);\n        if (firstTick < this.min) {\n            this.min = firstTick;\n        }\n        if (lastTick > this.max) {\n            this.max = lastTick;\n        }\n        // strict-limit 方式\n        if (!(0, util_1.isNil)(this.minLimit)) {\n            this.min = firstTick;\n        }\n        if (!(0, util_1.isNil)(this.maxLimit)) {\n            this.max = lastTick;\n        }\n    };\n    Continuous.prototype.setDomain = function () {\n        var _a = (0, util_1.getRange)(this.values), min = _a.min, max = _a.max;\n        if ((0, util_1.isNil)(this.min)) {\n            this.min = min;\n        }\n        if ((0, util_1.isNil)(this.max)) {\n            this.max = max;\n        }\n        if (this.min > this.max) {\n            this.min = min;\n            this.max = max;\n        }\n    };\n    Continuous.prototype.calculateTicks = function () {\n        var _this = this;\n        var ticks = _super.prototype.calculateTicks.call(this);\n        if (!this.nice) {\n            ticks = (0, util_1.filter)(ticks, function (tick) {\n                return tick >= _this.min && tick <= _this.max;\n            });\n        }\n        return ticks;\n    };\n    // 计算原始值值占的百分比\n    Continuous.prototype.getScalePercent = function (value) {\n        var max = this.max;\n        var min = this.min;\n        return (value - min) / (max - min);\n    };\n    Continuous.prototype.getInvertPercent = function (value) {\n        return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());\n    };\n    return Continuous;\n}(base_1.default));\nexports.default = Continuous;\n//# sourceMappingURL=base.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar math_1 = require(\"../util/math\");\nvar base_1 = require(\"./base\");\n/**\n * Log 度量，处理非均匀分布\n */\nvar Log = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Log, _super);\n    function Log() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'log';\n        return _this;\n    }\n    /**\n     * @override\n     */\n    Log.prototype.invert = function (value) {\n        var base = this.base;\n        var max = (0, math_1.log)(base, this.max);\n        var rangeMin = this.rangeMin();\n        var range = this.rangeMax() - rangeMin;\n        var min;\n        var positiveMin = this.positiveMin;\n        if (positiveMin) {\n            if (value === 0) {\n                return 0;\n            }\n            min = (0, math_1.log)(base, positiveMin / base);\n            var appendPercent = (1 / (max - min)) * range; // 0 到 positiveMin的占比\n            if (value < appendPercent) {\n                // 落到 0 - positiveMin 之间\n                return (value / appendPercent) * positiveMin;\n            }\n        }\n        else {\n            min = (0, math_1.log)(base, this.min);\n        }\n        var percent = (value - rangeMin) / range;\n        var tmp = percent * (max - min) + min;\n        return Math.pow(base, tmp);\n    };\n    Log.prototype.initCfg = function () {\n        this.tickMethod = 'log';\n        this.base = 10;\n        this.tickCount = 6;\n        this.nice = true;\n    };\n    // 设置\n    Log.prototype.setDomain = function () {\n        _super.prototype.setDomain.call(this);\n        var min = this.min;\n        if (min < 0) {\n            throw new Error('When you use log scale, the minimum value must be greater than zero!');\n        }\n        if (min === 0) {\n            this.positiveMin = (0, math_1.getLogPositiveMin)(this.values, this.base, this.max);\n        }\n    };\n    // 根据当前值获取占比\n    Log.prototype.getScalePercent = function (value) {\n        var max = this.max;\n        var min = this.min;\n        if (max === min) {\n            return 0;\n        }\n        // 如果值小于等于0，则按照0处理\n        if (value <= 0) {\n            return 0;\n        }\n        var base = this.base;\n        var positiveMin = this.positiveMin;\n        // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示\n        if (positiveMin) {\n            min = (positiveMin * 1) / base;\n        }\n        var percent;\n        // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例\n        if (value < positiveMin) {\n            percent = value / positiveMin / ((0, math_1.log)(base, max) - (0, math_1.log)(base, min));\n        }\n        else {\n            percent = ((0, math_1.log)(base, value) - (0, math_1.log)(base, min)) / ((0, math_1.log)(base, max) - (0, math_1.log)(base, min));\n        }\n        return percent;\n    };\n    return Log;\n}(base_1.default));\nexports.default = Log;\n//# sourceMappingURL=log.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.precisionAdd = exports.getLogPositiveMin = exports.log = exports.calBase = void 0;\nvar util_1 = require(\"@antv/util\");\n// 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\nfunction calBase(a, b) {\n    var e = Math.E;\n    var value;\n    if (b >= 0) {\n        value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n    }\n    else {\n        value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n    }\n    return value;\n}\nexports.calBase = calBase;\nfunction log(a, b) {\n    if (a === 1) {\n        return 1;\n    }\n    return Math.log(b) / Math.log(a);\n}\nexports.log = log;\nfunction getLogPositiveMin(values, base, max) {\n    if ((0, util_1.isNil)(max)) {\n        max = Math.max.apply(null, values);\n    }\n    var positiveMin = max;\n    (0, util_1.each)(values, function (value) {\n        if (value > 0 && value < positiveMin) {\n            positiveMin = value;\n        }\n    });\n    if (positiveMin === max) {\n        positiveMin = max / base;\n    }\n    if (positiveMin > 1) {\n        positiveMin = 1;\n    }\n    return positiveMin;\n}\nexports.getLogPositiveMin = getLogPositiveMin;\nfunction digitLength(num) {\n    // Get digit length of e\n    var eSplit = num.toString().split(/[eE]/);\n    var len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n    return len > 0 ? len : 0;\n}\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\nfunction precisionAdd(num1, num2) {\n    var num1Digits = digitLength(num1);\n    var num2Digits = digitLength(num2);\n    var baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));\n    return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\nexports.precisionAdd = precisionAdd;\n//# sourceMappingURL=math.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar math_1 = require(\"../util/math\");\nvar base_1 = require(\"./base\");\n/**\n * Pow 度量，处理非均匀分布\n */\nvar Pow = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Pow, _super);\n    function Pow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'pow';\n        return _this;\n    }\n    /**\n     * @override\n     */\n    Pow.prototype.invert = function (value) {\n        var percent = this.getInvertPercent(value);\n        var exponent = this.exponent;\n        var max = (0, math_1.calBase)(exponent, this.max);\n        var min = (0, math_1.calBase)(exponent, this.min);\n        var tmp = percent * (max - min) + min;\n        var factor = tmp >= 0 ? 1 : -1;\n        return Math.pow(tmp, exponent) * factor;\n    };\n    Pow.prototype.initCfg = function () {\n        this.tickMethod = 'pow';\n        this.exponent = 2;\n        this.tickCount = 5;\n        this.nice = true;\n    };\n    // 获取度量计算时，value占的定义域百分比\n    Pow.prototype.getScalePercent = function (value) {\n        var max = this.max;\n        var min = this.min;\n        if (max === min) {\n            return 0;\n        }\n        var exponent = this.exponent;\n        var percent = ((0, math_1.calBase)(exponent, value) - (0, math_1.calBase)(exponent, min)) / ((0, math_1.calBase)(exponent, max) - (0, math_1.calBase)(exponent, min));\n        return percent;\n    };\n    return Pow;\n}(base_1.default));\nexports.default = Pow;\n//# sourceMappingURL=pow.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar time_1 = require(\"../util/time\");\nvar linear_1 = require(\"./linear\");\n/**\n * 时间度量\n * @class\n */\nvar Time = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Time, _super);\n    function Time() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'time';\n        return _this;\n    }\n    /**\n     * @override\n     */\n    Time.prototype.getText = function (value, index) {\n        var numberValue = this.translate(value);\n        var formatter = this.formatter;\n        return formatter ? formatter(numberValue, index) : (0, time_1.timeFormat)(numberValue, this.mask);\n    };\n    /**\n     * @override\n     */\n    Time.prototype.scale = function (value) {\n        var v = value;\n        if ((0, util_1.isString)(v) || (0, util_1.isDate)(v)) {\n            v = this.translate(v);\n        }\n        return _super.prototype.scale.call(this, v);\n    };\n    /**\n     * 将时间转换成数字\n     * @override\n     */\n    Time.prototype.translate = function (v) {\n        return (0, time_1.toTimeStamp)(v);\n    };\n    Time.prototype.initCfg = function () {\n        this.tickMethod = 'time-pretty';\n        this.mask = 'YYYY-MM-DD';\n        this.tickCount = 7;\n        this.nice = false;\n    };\n    Time.prototype.setDomain = function () {\n        var values = this.values;\n        // 是否设置了 min, max，而不是直接取 this.min, this.max\n        var minConfig = this.getConfig('min');\n        var maxConfig = this.getConfig('max');\n        // 如果设置了 min,max 则转换成时间戳\n        if (!(0, util_1.isNil)(minConfig) || !(0, util_1.isNumber)(minConfig)) {\n            this.min = this.translate(this.min);\n        }\n        if (!(0, util_1.isNil)(maxConfig) || !(0, util_1.isNumber)(maxConfig)) {\n            this.max = this.translate(this.max);\n        }\n        // 没有设置 min, max 时\n        if (values && values.length) {\n            // 重新计算最大最小值\n            var timeStamps_1 = [];\n            var min_1 = Infinity; // 最小值\n            var secondMin_1 = min_1; // 次小值\n            var max_1 = 0;\n            // 使用一个循环，计算min,max,secondMin\n            (0, util_1.each)(values, function (v) {\n                var timeStamp = (0, time_1.toTimeStamp)(v);\n                if (isNaN(timeStamp)) {\n                    throw new TypeError(\"Invalid Time: \" + v + \" in time scale!\");\n                }\n                if (min_1 > timeStamp) {\n                    secondMin_1 = min_1;\n                    min_1 = timeStamp;\n                }\n                else if (secondMin_1 > timeStamp) {\n                    secondMin_1 = timeStamp;\n                }\n                if (max_1 < timeStamp) {\n                    max_1 = timeStamp;\n                }\n                timeStamps_1.push(timeStamp);\n            });\n            // 存在多个值时，设置最小间距\n            if (values.length > 1) {\n                this.minTickInterval = secondMin_1 - min_1;\n            }\n            if ((0, util_1.isNil)(minConfig)) {\n                this.min = min_1;\n            }\n            if ((0, util_1.isNil)(maxConfig)) {\n                this.max = max_1;\n            }\n        }\n    };\n    return Time;\n}(linear_1.default));\nexports.default = Time;\n//# sourceMappingURL=time.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"./base\");\n/**\n * 分段度量\n */\nvar Quantize = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Quantize, _super);\n    function Quantize() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'quantize';\n        return _this;\n    }\n    Quantize.prototype.invert = function (value) {\n        var ticks = this.ticks;\n        var length = ticks.length;\n        var percent = this.getInvertPercent(value);\n        var minIndex = Math.floor(percent * (length - 1));\n        // 最后一个\n        if (minIndex >= length - 1) {\n            return (0, util_1.last)(ticks);\n        }\n        // 超出左边界， 则取第一个\n        if (minIndex < 0) {\n            return (0, util_1.head)(ticks);\n        }\n        var minTick = ticks[minIndex];\n        var nextTick = ticks[minIndex + 1];\n        // 比当前值小的 tick 在度量上的占比\n        var minIndexPercent = minIndex / (length - 1);\n        var maxIndexPercent = (minIndex + 1) / (length - 1);\n        return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);\n    };\n    Quantize.prototype.initCfg = function () {\n        this.tickMethod = 'r-pretty';\n        this.tickCount = 5;\n        this.nice = true;\n    };\n    Quantize.prototype.calculateTicks = function () {\n        var ticks = _super.prototype.calculateTicks.call(this);\n        if (!this.nice) { // 如果 nice = false ,补充 min, max\n            if ((0, util_1.last)(ticks) !== this.max) {\n                ticks.push(this.max);\n            }\n            if ((0, util_1.head)(ticks) !== this.min) {\n                ticks.unshift(this.min);\n            }\n        }\n        return ticks;\n    };\n    // 计算当前值在刻度中的占比\n    Quantize.prototype.getScalePercent = function (value) {\n        var ticks = this.ticks;\n        // 超出左边界\n        if (value < (0, util_1.head)(ticks)) {\n            return 0;\n        }\n        // 超出右边界\n        if (value > (0, util_1.last)(ticks)) {\n            return 1;\n        }\n        var minIndex = 0;\n        (0, util_1.each)(ticks, function (tick, index) {\n            if (value >= tick) {\n                minIndex = index;\n            }\n            else {\n                return false;\n            }\n        });\n        return minIndex / (ticks.length - 1);\n    };\n    return Quantize;\n}(base_1.default));\nexports.default = Quantize;\n//# sourceMappingURL=quantize.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar quantize_1 = require(\"./quantize\");\nvar Quantile = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Quantile, _super);\n    function Quantile() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'quantile';\n        return _this;\n    }\n    Quantile.prototype.initCfg = function () {\n        this.tickMethod = 'quantile';\n        this.tickCount = 5;\n        this.nice = true;\n    };\n    return Quantile;\n}(quantize_1.default));\nexports.default = Quantile;\n//# sourceMappingURL=quantile.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerScale = exports.getScale = exports.Scale = void 0;\nvar base_1 = require(\"./base\");\nexports.Scale = base_1.default;\nvar map = {};\nfunction getClass(key) {\n    return map[key];\n}\nexports.getScale = getClass;\nfunction registerClass(key, cls) {\n    if (getClass(key)) {\n        throw new Error(\"type '\" + key + \"' existed.\");\n    }\n    map[key] = cls;\n}\nexports.registerScale = registerClass;\n//# sourceMappingURL=factory.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"@antv/util\");\nvar base_1 = require(\"../base\");\n/**\n * identity scale原则上是定义域和值域一致，scale/invert方法也是一致的\n * 参考R的实现：https://github.com/r-lib/scales/blob/master/R/pal-identity.r\n * 参考d3的实现（做了下转型）：https://github.com/d3/d3-scale/blob/master/src/identity.js\n */\nvar Identity = /** @class */ (function (_super) {\n    (0, tslib_1.__extends)(Identity, _super);\n    function Identity() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'identity';\n        _this.isIdentity = true;\n        return _this;\n    }\n    Identity.prototype.calculateTicks = function () {\n        return this.values;\n    };\n    Identity.prototype.scale = function (value) {\n        // 如果传入的值不等于 identity 的值，则直接返回，用于一维图时的 dodge\n        if (this.values[0] !== value && (0, util_1.isNumber)(value)) {\n            return value;\n        }\n        return this.range[0];\n    };\n    Identity.prototype.invert = function (value) {\n        var range = this.range;\n        if (value < range[0] || value > range[1]) {\n            return NaN;\n        }\n        return this.values[0];\n    };\n    return Identity;\n}(base_1.default));\nexports.default = Identity;\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerTickMethod = exports.getTickMethod = void 0;\nvar cat_1 = require(\"./cat\");\nvar d3_linear_1 = require(\"./d3-linear\");\nvar linear_1 = require(\"./linear\");\nvar log_1 = require(\"./log\");\nvar pow_1 = require(\"./pow\");\nvar quantile_1 = require(\"./quantile\");\nvar r_prettry_1 = require(\"./r-prettry\");\nvar register_1 = require(\"./register\");\nObject.defineProperty(exports, \"getTickMethod\", { enumerable: true, get: function () { return register_1.getTickMethod; } });\nObject.defineProperty(exports, \"registerTickMethod\", { enumerable: true, get: function () { return register_1.registerTickMethod; } });\nvar time_1 = require(\"./time\");\nvar time_cat_1 = require(\"./time-cat\");\nvar time_pretty_1 = require(\"./time-pretty\");\n(0, register_1.registerTickMethod)('cat', cat_1.default);\n(0, register_1.registerTickMethod)('time-cat', time_cat_1.default);\n(0, register_1.registerTickMethod)('wilkinson-extended', linear_1.default);\n(0, register_1.registerTickMethod)('r-pretty', r_prettry_1.default);\n(0, register_1.registerTickMethod)('time', time_1.default);\n(0, register_1.registerTickMethod)('time-pretty', time_pretty_1.default);\n(0, register_1.registerTickMethod)('log', log_1.default);\n(0, register_1.registerTickMethod)('pow', pow_1.default);\n(0, register_1.registerTickMethod)('quantile', quantile_1.default);\n(0, register_1.registerTickMethod)('d3-linear', d3_linear_1.default);\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar extended_1 = require(\"../util/extended\");\n/**\n * 计算分类 ticks\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction calculateCatTicks(cfg) {\n    var values = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount;\n    var ticks = values;\n    if ((0, util_1.isNumber)(tickInterval)) {\n        return (0, util_1.filter)(ticks, function (__, i) { return i % tickInterval === 0; });\n    }\n    var min = cfg.min, max = cfg.max;\n    if ((0, util_1.isNil)(min)) {\n        min = 0;\n    }\n    if ((0, util_1.isNil)(max)) {\n        max = values.length - 1;\n    }\n    if ((0, util_1.isNumber)(tickCount) && tickCount < max - min) {\n        // 简单过滤，部分情况下小数的倍数也可以是整数\n        // tslint:disable-next-line: no-shadowed-variable\n        var ticks_1 = (0, extended_1.default)(min, max, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;\n        var valid = (0, util_1.filter)(ticks_1, function (tick) { return tick >= min && tick <= max; });\n        return valid.map(function (index) { return values[index]; });\n    }\n    return values.slice(min, max + 1);\n}\nexports.default = calculateCatTicks;\n//# sourceMappingURL=cat.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ALL_Q = exports.DEFAULT_Q = void 0;\nvar util_1 = require(\"@antv/util\");\nvar pretty_number_1 = require(\"./pretty-number\");\nexports.DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];\nexports.ALL_Q = [1, 5, 2, 2.5, 4, 3, 1.5, 7, 6, 8, 9];\nvar eps = Number.EPSILON * 100;\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\nfunction round(n) {\n    return Math.round(n * 1e12) / 1e12;\n}\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n    var n = (0, util_1.size)(Q);\n    var i = (0, util_1.indexOf)(Q, q);\n    var v = 0;\n    var m = mod(lmin, lstep);\n    if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {\n        v = 1;\n    }\n    return 1 - i / (n - 1) - j + v;\n}\nfunction simplicityMax(q, Q, j) {\n    var n = (0, util_1.size)(Q);\n    var i = (0, util_1.indexOf)(Q, q);\n    var v = 1;\n    return 1 - i / (n - 1) - j + v;\n}\nfunction density(k, m, dMin, dMax, lMin, lMax) {\n    var r = (k - 1) / (lMax - lMin);\n    var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));\n    return 2 - Math.max(r / rt, rt / r);\n}\nfunction densityMax(k, m) {\n    if (k >= m) {\n        return 2 - (k - 1) / (m - 1);\n    }\n    return 1;\n}\nfunction coverage(dMin, dMax, lMin, lMax) {\n    var range = dMax - dMin;\n    return 1 - (0.5 * (Math.pow((dMax - lMax), 2) + Math.pow((dMin - lMin), 2))) / Math.pow((0.1 * range), 2);\n}\nfunction coverageMax(dMin, dMax, span) {\n    var range = dMax - dMin;\n    if (span > range) {\n        var half = (span - range) / 2;\n        return 1 - Math.pow(half, 2) / Math.pow((0.1 * range), 2);\n    }\n    return 1;\n}\nfunction legibility() {\n    return 1;\n}\n/**\n * An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes\n * https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf\n * @param dMin 最小值\n * @param dMax 最大值\n * @param m tick个数\n * @param onlyLoose 是否允许扩展min、max，不绝对强制，例如[3, 97]\n * @param Q nice numbers集合\n * @param w 四个优化组件的权重\n */\nfunction extended(dMin, dMax, n, onlyLoose, Q, w) {\n    if (n === void 0) { n = 5; }\n    if (onlyLoose === void 0) { onlyLoose = true; }\n    if (Q === void 0) { Q = exports.DEFAULT_Q; }\n    if (w === void 0) { w = [0.25, 0.2, 0.5, 0.05]; }\n    // 处理小于 0 和小数的 tickCount\n    var m = n < 0 ? 0 : Math.round(n);\n    // nan 也会导致异常\n    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== 'number' || typeof dMax !== 'number' || !m) {\n        return {\n            min: 0,\n            max: 0,\n            ticks: [],\n        };\n    }\n    // js 极大值极小值问题，差值小于 1e-15 会导致计算出错\n    if (dMax - dMin < 1e-15 || m === 1) {\n        return {\n            min: dMin,\n            max: dMax,\n            ticks: [dMin],\n        };\n    }\n    var best = {\n        score: -2,\n        lmin: 0,\n        lmax: 0,\n        lstep: 0,\n    };\n    var j = 1;\n    while (j < Infinity) {\n        for (var i = 0; i < Q.length; i += 1) {\n            var q = Q[i];\n            var sm = simplicityMax(q, Q, j);\n            if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n                j = Infinity;\n                break;\n            }\n            var k = 2;\n            while (k < Infinity) {\n                var dm = densityMax(k, m);\n                if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n                    break;\n                }\n                var delta = (dMax - dMin) / (k + 1) / j / q;\n                var z = Math.ceil(Math.log10(delta));\n                while (z < Infinity) {\n                    var step = j * q * Math.pow(10, z);\n                    var cm = coverageMax(dMin, dMax, step * (k - 1));\n                    if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n                        break;\n                    }\n                    var minStart = Math.floor(dMax / step) * j - (k - 1) * j;\n                    var maxStart = Math.ceil(dMin / step) * j;\n                    if (minStart <= maxStart) {\n                        var count = maxStart - minStart;\n                        for (var i_1 = 0; i_1 <= count; i_1 += 1) {\n                            var start = minStart + i_1;\n                            var lMin = start * (step / j);\n                            var lMax = lMin + step * (k - 1);\n                            var lStep = step;\n                            var s = simplicity(q, Q, j, lMin, lMax, lStep);\n                            var c = coverage(dMin, dMax, lMin, lMax);\n                            var g = density(k, m, dMin, dMax, lMin, lMax);\n                            var l = legibility();\n                            var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n                            if (score > best.score && (!onlyLoose || (lMin <= dMin && lMax >= dMax))) {\n                                best.lmin = lMin;\n                                best.lmax = lMax;\n                                best.lstep = lStep;\n                                best.score = score;\n                            }\n                        }\n                    }\n                    z += 1;\n                }\n                k += 1;\n            }\n        }\n        j += 1;\n    }\n    // 处理精度问题，保证这三个数没有精度问题\n    var lmax = (0, pretty_number_1.prettyNumber)(best.lmax);\n    var lmin = (0, pretty_number_1.prettyNumber)(best.lmin);\n    var lstep = (0, pretty_number_1.prettyNumber)(best.lstep);\n    // 加 round 是为处理 extended(0.94, 1, 5)\n    // 保证生成的 tickCount 没有精度问题\n    var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;\n    var ticks = new Array(tickCount);\n    // 少用乘法：防止出现 -1.2 + 1.2 * 3 = 2.3999999999999995 的情况\n    ticks[0] = (0, pretty_number_1.prettyNumber)(lmin);\n    for (var i = 1; i < tickCount; i++) {\n        ticks[i] = (0, pretty_number_1.prettyNumber)(ticks[i - 1] + lstep);\n    }\n    return {\n        min: Math.min(dMin, (0, util_1.head)(ticks)),\n        max: Math.max(dMax, (0, util_1.last)(ticks)),\n        ticks: ticks,\n    };\n}\nexports.default = extended;\n//# sourceMappingURL=extended.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prettyNumber = void 0;\n// 为了解决 js 运算的精度问题\nfunction prettyNumber(n) {\n    return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));\n}\nexports.prettyNumber = prettyNumber;\n//# sourceMappingURL=pretty-number.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar d3_linear_1 = require(\"../util/d3-linear\");\nvar interval_1 = require(\"../util/interval\");\nvar strict_limit_1 = require(\"../util/strict-limit\");\nfunction d3LinearTickMethod(cfg) {\n    var min = cfg.min, max = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;\n    var ticks = (0, d3_linear_1.default)(cfg);\n    if (!(0, util_1.isNil)(minLimit) || !(0, util_1.isNil)(maxLimit)) {\n        return (0, strict_limit_1.default)(cfg, (0, util_1.head)(ticks), (0, util_1.last)(ticks));\n    }\n    if (tickInterval) {\n        return (0, interval_1.default)(min, max, tickInterval).ticks;\n    }\n    return ticks;\n}\nexports.default = d3LinearTickMethod;\n//# sourceMappingURL=d3-linear.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.D3Linear = void 0;\nfunction d3Linear(cfg) {\n    var min = cfg.min, max = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;\n    var linear = new D3Linear();\n    linear.domain([min, max]);\n    if (nice) {\n        linear.nice(tickCount);\n    }\n    return linear.ticks(tickCount);\n}\nexports.default = d3Linear;\nvar DEFAULT_COUNT = 5;\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n// https://github.com/d3/d3-scale\nvar D3Linear = /** @class */ (function () {\n    function D3Linear() {\n        this._domain = [0, 1];\n    }\n    D3Linear.prototype.domain = function (domain) {\n        if (domain) {\n            this._domain = Array.from(domain, Number);\n            return this;\n        }\n        return this._domain.slice();\n    };\n    D3Linear.prototype.nice = function (count) {\n        var _a, _b;\n        if (count === void 0) { count = DEFAULT_COUNT; }\n        var d = this._domain.slice();\n        var i0 = 0;\n        var i1 = this._domain.length - 1;\n        var start = this._domain[i0];\n        var stop = this._domain[i1];\n        var step;\n        if (stop < start) {\n            _a = [stop, start], start = _a[0], stop = _a[1];\n            _b = [i1, i0], i0 = _b[0], i1 = _b[1];\n        }\n        step = tickIncrement(start, stop, count);\n        if (step > 0) {\n            start = Math.floor(start / step) * step;\n            stop = Math.ceil(stop / step) * step;\n            step = tickIncrement(start, stop, count);\n        }\n        else if (step < 0) {\n            start = Math.ceil(start * step) / step;\n            stop = Math.floor(stop * step) / step;\n            step = tickIncrement(start, stop, count);\n        }\n        if (step > 0) {\n            d[i0] = Math.floor(start / step) * step;\n            d[i1] = Math.ceil(stop / step) * step;\n            this.domain(d);\n        }\n        else if (step < 0) {\n            d[i0] = Math.ceil(start * step) / step;\n            d[i1] = Math.floor(stop * step) / step;\n            this.domain(d);\n        }\n        return this;\n    };\n    D3Linear.prototype.ticks = function (count) {\n        if (count === void 0) { count = DEFAULT_COUNT; }\n        return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);\n    };\n    return D3Linear;\n}());\nexports.D3Linear = D3Linear;\nfunction d3ArrayTicks(start, stop, count) {\n    var reverse;\n    var i = -1;\n    var n;\n    var ticks;\n    var step;\n    (stop = +stop), (start = +start), (count = +count);\n    if (start === stop && count > 0) {\n        return [start];\n    }\n    // tslint:disable-next-line\n    if ((reverse = stop < start)) {\n        (n = start), (start = stop), (stop = n);\n    }\n    // tslint:disable-next-line\n    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {\n        return [];\n    }\n    if (step > 0) {\n        start = Math.ceil(start / step);\n        stop = Math.floor(stop / step);\n        ticks = new Array((n = Math.ceil(stop - start + 1)));\n        while (++i < n) {\n            ticks[i] = (start + i) * step;\n        }\n    }\n    else {\n        start = Math.floor(start * step);\n        stop = Math.ceil(stop * step);\n        ticks = new Array((n = Math.ceil(start - stop + 1)));\n        while (++i < n) {\n            ticks[i] = (start - i) / step;\n        }\n    }\n    if (reverse) {\n        ticks.reverse();\n    }\n    return ticks;\n}\nfunction tickIncrement(start, stop, count) {\n    var step = (stop - start) / Math.max(0, count);\n    var power = Math.floor(Math.log(step) / Math.LN10);\n    var error = step / Math.pow(10, power);\n    return power >= 0\n        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n//# sourceMappingURL=d3-linear.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nfunction snapMultiple(v, base, snapType) {\n    var div;\n    if (snapType === 'ceil') {\n        div = Math.ceil(v / base);\n    }\n    else if (snapType === 'floor') {\n        div = Math.floor(v / base);\n    }\n    else {\n        div = Math.round(v / base);\n    }\n    return div * base;\n}\nfunction intervalTicks(min, max, interval) {\n    // 变成 interval 的倍数\n    var minTick = snapMultiple(min, interval, 'floor');\n    var maxTick = snapMultiple(max, interval, 'ceil');\n    // 统一小数位数\n    minTick = (0, util_1.fixedBase)(minTick, interval);\n    maxTick = (0, util_1.fixedBase)(maxTick, interval);\n    var ticks = [];\n    for (var i = minTick; i <= maxTick; i = i + interval) {\n        var tickValue = (0, util_1.fixedBase)(i, interval); // 防止浮点数加法出现问题\n        ticks.push(tickValue);\n    }\n    return {\n        min: minTick,\n        max: maxTick,\n        ticks: ticks\n    };\n}\nexports.default = intervalTicks;\n//# sourceMappingURL=interval.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\n/**\n * 按照给定的 minLimit/maxLimit/tickCount 均匀计算出刻度 ticks\n *\n * @param cfg Scale 配置项\n * @return ticks\n */\nfunction strictLimit(cfg, defaultMin, defaultMax) {\n    var _a;\n    var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min = cfg.min, max = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;\n    var tickMin = (0, util_1.isNil)(minLimit) ? ((0, util_1.isNil)(defaultMin) ? min : defaultMin) : minLimit;\n    var tickMax = (0, util_1.isNil)(maxLimit) ? ((0, util_1.isNil)(defaultMax) ? max : defaultMax) : maxLimit;\n    if (tickMin > tickMax) {\n        _a = [tickMin, tickMax], tickMax = _a[0], tickMin = _a[1];\n    }\n    if (tickCount <= 2) {\n        return [tickMin, tickMax];\n    }\n    var step = (tickMax - tickMin) / (tickCount - 1);\n    var ticks = [];\n    for (var i = 0; i < tickCount; i++) {\n        ticks.push(tickMin + step * i);\n    }\n    return ticks;\n}\nexports.default = strictLimit;\n//# sourceMappingURL=strict-limit.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar extended_1 = require(\"../util/extended\");\nvar interval_1 = require(\"../util/interval\");\nvar strict_limit_1 = require(\"../util/strict-limit\");\n/**\n * 计算线性的 ticks，使用 wilkinson extended 方法\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction linear(cfg) {\n    var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;\n    var ticks = (0, extended_1.default)(min, max, tickCount, nice).ticks;\n    if (!(0, util_1.isNil)(minLimit) || !(0, util_1.isNil)(maxLimit)) {\n        return (0, strict_limit_1.default)(cfg, (0, util_1.head)(ticks), (0, util_1.last)(ticks));\n    }\n    if (tickInterval) {\n        return (0, interval_1.default)(min, max, tickInterval).ticks;\n    }\n    return ticks;\n}\nexports.default = linear;\n//# sourceMappingURL=linear.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = require(\"../util/math\");\n/**\n * 计算 log 的 ticks，考虑 min = 0 的场景\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction calculateLogTicks(cfg) {\n    var base = cfg.base, tickCount = cfg.tickCount, min = cfg.min, max = cfg.max, values = cfg.values;\n    var minTick;\n    var maxTick = (0, math_1.log)(base, max);\n    if (min > 0) {\n        minTick = Math.floor((0, math_1.log)(base, min));\n    }\n    else {\n        var positiveMin = (0, math_1.getLogPositiveMin)(values, base, max);\n        minTick = Math.floor((0, math_1.log)(base, positiveMin));\n    }\n    var count = maxTick - minTick;\n    var avg = Math.ceil(count / tickCount);\n    var ticks = [];\n    for (var i = minTick; i < maxTick + avg; i = i + avg) {\n        ticks.push(Math.pow(base, i));\n    }\n    if (min <= 0) {\n        // 最小值 <= 0 时显示 0\n        ticks.unshift(0);\n    }\n    return ticks;\n}\nexports.default = calculateLogTicks;\n//# sourceMappingURL=log.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = require(\"../util/math\");\nvar pretty_1 = require(\"../util/pretty\");\n/**\n * 计算 Pow 的 ticks\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction calculatePowTicks(cfg) {\n    var exponent = cfg.exponent, tickCount = cfg.tickCount;\n    var max = Math.ceil((0, math_1.calBase)(exponent, cfg.max));\n    var min = Math.floor((0, math_1.calBase)(exponent, cfg.min));\n    var ticks = (0, pretty_1.default)(min, max, tickCount).ticks;\n    return ticks.map(function (tick) {\n        var factor = tick >= 0 ? 1 : -1;\n        return Math.pow(tick, exponent) * factor;\n    });\n}\nexports.default = calculatePowTicks;\n//# sourceMappingURL=pow.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pretty_number_1 = require(\"./pretty-number\");\nfunction pretty(min, max, m) {\n    if (m === void 0) { m = 5; }\n    if (min === max) {\n        return {\n            max: max,\n            min: min,\n            ticks: [min],\n        };\n    }\n    var n = m < 0 ? 0 : Math.round(m);\n    if (n === 0)\n        return { max: max, min: min, ticks: [] };\n    /*\n      R pretty:\n      https://svn.r-project.org/R/trunk/src/appl/pretty.c\n      https://www.rdocumentation.org/packages/base/versions/3.5.2/topics/pretty\n      */\n    var h = 1.5; // high.u.bias\n    var h5 = 0.5 + 1.5 * h; // u5.bias\n    // 反正我也不会调参，跳过所有判断步骤\n    var d = max - min;\n    var c = d / n;\n    // 当d非常小的时候触发，但似乎没什么用\n    // const min_n = Math.floor(n / 3);\n    // const shrink_sml = Math.pow(2, 5);\n    // if (Math.log10(d) < -2) {\n    //   c = (_.max([ Math.abs(max), Math.abs(min) ]) * shrink_sml) / min_n;\n    // }\n    var base = Math.pow(10, Math.floor(Math.log10(c)));\n    var unit = base;\n    if (2 * base - c < h * (c - unit)) {\n        unit = 2 * base;\n        if (5 * base - c < h5 * (c - unit)) {\n            unit = 5 * base;\n            if (10 * base - c < h * (c - unit)) {\n                unit = 10 * base;\n            }\n        }\n    }\n    var nu = Math.ceil(max / unit);\n    var ns = Math.floor(min / unit);\n    var hi = Math.max(nu * unit, max);\n    var lo = Math.min(ns * unit, min);\n    var size = Math.floor((hi - lo) / unit) + 1;\n    var ticks = new Array(size);\n    for (var i = 0; i < size; i++) {\n        ticks[i] = (0, pretty_number_1.prettyNumber)(lo + i * unit);\n    }\n    return {\n        min: lo,\n        max: hi,\n        ticks: ticks,\n    };\n}\nexports.default = pretty;\n//# sourceMappingURL=pretty.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 计算几分位 https://github.com/simple-statistics/simple-statistics/blob/master/src/quantile_sorted.js\n * @param x  数组\n * @param p  百分比\n */\nfunction quantileSorted(x, p) {\n    var idx = x.length * p;\n    /*if (x.length === 0) { // 当前场景这些条件不可能命中\n      throw new Error('quantile requires at least one value.');\n    } else if (p < 0 || p > 1) {\n      throw new Error('quantiles must be between 0 and 1');\n    } else */\n    if (p === 1) {\n        // If p is 1, directly return the last element\n        return x[x.length - 1];\n    }\n    else if (p === 0) {\n        // If p is 0, directly return the first element\n        return x[0];\n    }\n    else if (idx % 1 !== 0) {\n        // If p is not integer, return the next element in array\n        return x[Math.ceil(idx) - 1];\n    }\n    else if (x.length % 2 === 0) {\n        // If the list has even-length, we'll take the average of this number\n        // and the next value, if there is one\n        return (x[idx - 1] + x[idx]) / 2;\n    }\n    else {\n        // Finally, in the simple case of an integer value\n        // with an odd-length list, return the x value at the index.\n        return x[idx];\n    }\n}\nfunction calculateTicks(cfg) {\n    var tickCount = cfg.tickCount, values = cfg.values;\n    if (!values || !values.length) {\n        return [];\n    }\n    var sorted = values.slice().sort(function (a, b) {\n        return a - b;\n    });\n    var ticks = [];\n    for (var i = 0; i < tickCount; i++) {\n        var p = i / (tickCount - 1);\n        ticks.push(quantileSorted(sorted, p));\n    }\n    return ticks;\n}\nexports.default = calculateTicks;\n//# sourceMappingURL=quantile.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar interval_1 = require(\"../util/interval\");\nvar pretty_1 = require(\"../util/pretty\");\nvar strict_limit_1 = require(\"../util/strict-limit\");\n/**\n * 计算线性的 ticks，使用 R's pretty 方法\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction linearPretty(cfg) {\n    var min = cfg.min, max = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;\n    var ticks = (0, pretty_1.default)(min, max, tickCount).ticks;\n    if (!(0, util_1.isNil)(minLimit) || !(0, util_1.isNil)(maxLimit)) {\n        return (0, strict_limit_1.default)(cfg, (0, util_1.head)(ticks), (0, util_1.last)(ticks));\n    }\n    if (tickInterval) {\n        return (0, interval_1.default)(min, max, tickInterval).ticks;\n    }\n    return ticks;\n}\nexports.default = linearPretty;\n//# sourceMappingURL=r-prettry.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar time_1 = require(\"../util/time\");\nfunction calculateTimeTicks(cfg) {\n    var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval;\n    var tickInterval = cfg.tickInterval;\n    var tickCount = cfg.tickCount;\n    // 指定 tickInterval 后 tickCount 不生效，需要重新计算\n    if (tickInterval) {\n        tickCount = Math.ceil((max - min) / tickInterval);\n    }\n    else {\n        tickInterval = (0, time_1.getTickInterval)(min, max, tickCount)[1];\n        var count = (max - min) / tickInterval;\n        var ratio = count / tickCount;\n        if (ratio > 1) {\n            tickInterval = tickInterval * Math.ceil(ratio);\n        }\n        // 如果设置了最小间距，则使用最小间距\n        if (minTickInterval && tickInterval < minTickInterval) {\n            tickInterval = minTickInterval;\n        }\n    }\n    var ticks = [];\n    for (var i = min; i < max + tickInterval; i += tickInterval) {\n        ticks.push(i);\n    }\n    return ticks;\n}\nexports.default = calculateTimeTicks;\n//# sourceMappingURL=time.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@antv/util\");\nvar cat_1 = require(\"./cat\");\n/**\n * 计算时间分类的 ticks, 保头，保尾\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction calculateTimeCatTicks(cfg) {\n    var ticks = (0, cat_1.default)(cfg);\n    var lastValue = (0, util_1.last)(cfg.values);\n    if (lastValue !== (0, util_1.last)(ticks)) {\n        ticks.push(lastValue);\n    }\n    return ticks;\n}\nexports.default = calculateTimeCatTicks;\n//# sourceMappingURL=time-cat.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar time_1 = require(\"../util/time\");\nfunction getYear(date) {\n    return new Date(date).getFullYear();\n}\nfunction createYear(year) {\n    return new Date(year, 0, 1).getTime();\n}\nfunction getMonth(date) {\n    return new Date(date).getMonth();\n}\nfunction diffMonth(min, max) {\n    var minYear = getYear(min);\n    var maxYear = getYear(max);\n    var minMonth = getMonth(min);\n    var maxMonth = getMonth(max);\n    return (maxYear - minYear) * 12 + ((maxMonth - minMonth) % 12);\n}\nfunction creatMonth(year, month) {\n    return new Date(year, month, 1).getTime();\n}\nfunction diffDay(min, max) {\n    return Math.ceil((max - min) / time_1.DAY);\n}\nfunction diffHour(min, max) {\n    return Math.ceil((max - min) / time_1.HOUR);\n}\nfunction diffMinus(min, max) {\n    return Math.ceil((max - min) / (60 * 1000));\n}\n/**\n * 计算 time 的 ticks，对 month, year 进行 pretty 处理\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nfunction timePretty(cfg) {\n    var min = cfg.min, max = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;\n    var tickInterval = cfg.tickInterval;\n    var ticks = [];\n    // 指定 tickInterval 后 tickCount 不生效，需要重新计算\n    if (!tickInterval) {\n        tickInterval = (max - min) / tickCount;\n        // 如果设置了最小间距，则使用最小间距\n        if (minTickInterval && tickInterval < minTickInterval) {\n            tickInterval = minTickInterval;\n        }\n    }\n    var minYear = getYear(min);\n    // 如果间距大于 1 年，则将开始日期从整年开始\n    if (tickInterval > time_1.YEAR) {\n        var maxYear = getYear(max);\n        var yearInterval = Math.ceil(tickInterval / time_1.YEAR);\n        for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {\n            ticks.push(createYear(i));\n        }\n    }\n    else if (tickInterval > time_1.MONTH) {\n        // 大于月时\n        var monthInterval = Math.ceil(tickInterval / time_1.MONTH);\n        var mmMoth = getMonth(min);\n        var dMonths = diffMonth(min, max);\n        for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {\n            ticks.push(creatMonth(minYear, i + mmMoth));\n        }\n    }\n    else if (tickInterval > time_1.DAY) {\n        // 大于天\n        var date = new Date(min);\n        var year = date.getFullYear();\n        var month = date.getMonth();\n        var mday = date.getDate();\n        var day = Math.ceil(tickInterval / time_1.DAY);\n        var ddays = diffDay(min, max);\n        for (var i = 0; i < ddays + day; i = i + day) {\n            ticks.push(new Date(year, month, mday + i).getTime());\n        }\n    }\n    else if (tickInterval > time_1.HOUR) {\n        // 大于小时\n        var date = new Date(min);\n        var year = date.getFullYear();\n        var month = date.getMonth();\n        var day = date.getDate();\n        var hour = date.getHours();\n        var hours = Math.ceil(tickInterval / time_1.HOUR);\n        var dHours = diffHour(min, max);\n        for (var i = 0; i <= dHours + hours; i = i + hours) {\n            ticks.push(new Date(year, month, day, hour + i).getTime());\n        }\n    }\n    else if (tickInterval > time_1.MINUTE) {\n        // 大于分钟\n        var dMinus = diffMinus(min, max);\n        var minutes = Math.ceil(tickInterval / time_1.MINUTE);\n        for (var i = 0; i <= dMinus + minutes; i = i + minutes) {\n            ticks.push(min + i * time_1.MINUTE);\n        }\n    }\n    else {\n        // 小于分钟\n        var interval = tickInterval;\n        if (interval < time_1.SECOND) {\n            interval = time_1.SECOND;\n        }\n        var minSecond = Math.floor(min / time_1.SECOND) * time_1.SECOND;\n        var dSeconds = Math.ceil((max - min) / time_1.SECOND);\n        var seconds = Math.ceil(interval / time_1.SECOND);\n        for (var i = 0; i < dSeconds + seconds; i = i + seconds) {\n            ticks.push(minSecond + i * time_1.SECOND);\n        }\n    }\n    // 最好是能从算法能解决这个问题，但是如果指定了 tickInterval，计算 ticks，也只能这么算，所以\n    // 打印警告提示\n    if (ticks.length >= 512) {\n        console.warn(\"Notice: current ticks length(\" + ticks.length + \") >= 512, may cause performance issues, even out of memory. Because of the configure \\\"tickInterval\\\"(in milliseconds, current is \" + tickInterval + \") is too small, increase the value to solve the problem!\");\n    }\n    return ticks;\n}\nexports.default = timePretty;\n//# sourceMappingURL=time-pretty.js.map"]}